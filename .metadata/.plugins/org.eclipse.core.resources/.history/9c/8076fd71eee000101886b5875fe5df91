#include "stm32f4xx.h"
#include "clock.h"
#include "uart.h"
#include "stdint.h"
#include "eeprom.h"
#include "boot_metadata.h"
#include "image_validate.h"
#include "memory_map.h"

static void platform_init(void)
{
    clock_init_minimal();
    uart_init();
    eeprom_init();
}

//static uint32_t boot_read_reset_cause(void) {
//	uint32_t csr = RCC->CSR; /* Clear reset flags for next reset */
//RCC->CSR |= RCC_CSR_RMVF; return csr;
//}

static void boot_diagnostics(void)
{
    uart_puts("\r\nBOOTLOADER START\r\n");

   // uint32_t reset_cause = boot_read_reset_cause();
   // boot_print_reset_cause(reset_cause);
}

static int boot_metadata_init_and_load(boot_metadata_t *meta)
{
    if (boot_metadata_load_or_init(meta) != 0)
    {
        uart_puts("METADATA ERROR\r\n");
        return -1;
    }

    uart_puts("METADATA OK\r\n");
    return 0;
}

static void boot_decision_stage(void)
{
	uart_puts("BOOT DECISION: STAY IN BOOTLOADER\r\n");
}

static void boot_cli_loop(void)
{
    uart_puts("BOOTLOADER READY\r\n> ");

    while (1)
    {
        char c = uart_getc();
        uart_putc(c);
    }
}

static const char *img_status_str(img_status_t st)
{
    switch (st)
    {
        case IMG_OK:               return "OK";
        case IMG_ERR_ZERO_VECTOR:  return "ZERO_VECTOR";
        case IMG_ERR_MSP_RANGE:    return "MSP_RANGE";
        case IMG_ERR_MSP_ALIGN:    return "MSP_ALIGN";
        case IMG_ERR_RESET_RANGE:  return "RESET_RANGE";
        case IMG_ERR_RESET_THUMB:  return "RESET_THUMB";
        default:                   return "UNKNOWN";
    }
}

void bootloader_test_vector_validation(void)
{
    img_status_t a = image_validate_vector(APP_SLOT_A_BASE);
    img_status_t b = image_validate_vector(APP_SLOT_B_BASE);

    uart_printf("Slot A vector: %s\r\n", img_status_str(a));
    uart_printf("Slot B vector: %s\r\n", img_status_str(b));
}

int main(void)
{
    boot_metadata_t meta;

    platform_init();
    bootloader_test_vector_validation();
    boot_diagnostics();

    if (boot_metadata_init_and_load(&meta) == 0)
    {
        boot_metadata_dump(&meta);
    }

    boot_decision_stage();
    boot_cli_loop();

    while(1){
    	char c=uart_getc();
    	uart_putc(c);
    }
}
