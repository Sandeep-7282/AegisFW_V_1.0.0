#include "boot_decision.h"
#include "boot_metadata.h"
#include "image_validate.h"
#include "image_crc.h"
#include "memory_map.h"
#include "uart.h"
#include "stm32f4xx.h"

#define MAX_BOOT_RETRIES   3


uint32_t slot_base_addr(uint8_t slot)
{
    return (slot == SLOT_A) ? APP_SLOT_A_BASE : APP_SLOT_B_BASE;
}


/*-------------------------------------------------------------*
 *               FINAL BOOT DECISION FUNCTION
 *-------------------------------------------------------------*/
boot_decision_t boot_decide(boot_metadata_t *meta)
{
    uint32_t base = slot_base_addr(meta->active_slot);

    uart_puts("Running Boot Decision...\r\n");

    /*-------------------------------------------------------------*
     * 0) No image on both slots → stay in BL
     *-------------------------------------------------------------*/
    bool A_valid = (image_validate_vector(APP_SLOT_A_BASE) == IMG_OK);
    bool B_valid = (image_validate_vector(APP_SLOT_B_BASE) == IMG_OK);

    if (!A_valid && !B_valid)
    {
        uart_puts("\r\n*** FATAL: No valid images available ***\r\n");
        uart_puts("System will stay in Bootloader.\r\n\n");
        return BOOT_DECISION_STAY;
    }


    /*-------------------------------------------------------------*
     * 1) VECTOR VALIDATION WITH RETRY
     *-------------------------------------------------------------*/
    if (image_validate_vector(base) != IMG_OK)
    {
        uart_puts("Vector invalid → marking failure\r\n");

        meta->boot_attempts++;
        meta->checksum = metadata_checksum(meta);
        boot_metadata_store_safe(meta);

        if (meta->boot_attempts < MAX_BOOT_RETRIES)
        {
            uart_printf("Retry %d/%d next reset\r\n\n",
                        meta->boot_attempts, MAX_BOOT_RETRIES);
            return BOOT_DECISION_STAY;              // try same slot again next boot
        }

        uart_puts("Max retries reached → Rolling back to other slot\r\n");
        meta->active_slot = (meta->active_slot == SLOT_A) ? SLOT_B : SLOT_A;
        meta->boot_attempts = 0;
        meta->checksum = metadata_checksum(meta);
        boot_metadata_store_safe(meta);

        return BOOT_DECISION_ROLLBACK;
    }


    /*-------------------------------------------------------------*
     * 2) CRC VALIDATION / ENROLLMENT / RETRY
     *-------------------------------------------------------------*/
    uint32_t crc = crc32_compute_flash(base + 8U,
                                       APP_SLOT_SIZE_BYTES - 8U);

    /* CASE-A: First valid run → enroll CRC */
    if (meta->image_crc == 0)
    {
        uart_puts("First boot of slot → enrolling CRC\r\n");

        meta->image_crc = crc;
        meta->boot_attempts = 0;
        meta->checksum = metadata_checksum(meta);
        boot_metadata_store_safe(meta);

        return BOOT_DECISION_BOOT;
    }

    /* CASE-B: CRC mismatch → retry then rollback */
    if (crc != meta->image_crc)
    {
        uart_puts("CRC mismatch detected\r\n");

        meta->boot_attempts++;
        meta->checksum = metadata_checksum(meta);
        boot_metadata_store_safe(meta);

        if (meta->boot_attempts < MAX_BOOT_RETRIES)
        {
            printf("Retry %d/%d next reset\r\n\n",
                        meta->boot_attempts, MAX_BOOT_RETRIES);
            return BOOT_DECISION_STAY;
        }

        uart_puts("Max retries reached → switching slot\r\n");
        meta->active_slot = (meta->active_slot == SLOT_A) ? SLOT_B : SLOT_A;
        meta->boot_attempts = 0;
        meta->checksum = metadata_checksum(meta);
        boot_metadata_store_safe(meta);

        return BOOT_DECISION_ROLLBACK;
    }


    /*-------------------------------------------------------------*
     * CASE-C: CRC MATCH → boot normally
     *-------------------------------------------------------------*/
    uart_puts("Image valid & CRC matches\r\n");

    meta->boot_attempts = 0;
    meta->checksum = metadata_checksum(meta);
    boot_metadata_store_safe(meta);

    return BOOT_DECISION_BOOT;
}
